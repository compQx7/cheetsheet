# HTTPプロトコル
クライアント→webサーバー HTTPリクエスト（リクエストメソッドの代表としてGETとPOST）
webサーバー→クライアント HTTPレスポンス

## リクエスト
リクエスト行 リクエストメソッド、URLなど
メッセージヘッダー ブラウザ情報など
メッセージボディ 送るデータがあれば利用

### GET
URLにパラメータを付けて送る。URLの「?」以降がパラメーター。パラメーターが複数ある場合は「＆」で繋ぐ。
→他人にに見られてはいけない情報（パスワードなど）はGETで送らない
→URLには長さ制限があるため、付けられる情報量（パラメーター）に限界がある
主にhtmlファイルやリソースを取得する際に利用

### POST
POSTはリクエストボディに付けて送る。
主に入力した情報をサーバーに転送する際に利用
その他、データ量が多い時やバイナリデータを送る時に利用

## レスポンス
ステータス行 200、404とか
メッセージヘッダー
メッセージボディ htmlや画像データ（ブラウザが読み取って表示する部分）

# webページの表示の仕組み
* ブラウザはレンダリングエンジンがHTMLを解釈して表示する。ブラウザごとにレンダリングエンジンは異なる。そのためwebサイトを作成した際は複数のブラウザで動作確認を行う必要がある。

# Web Components
* 再利用性があり、カプセル化された独自HTMLタグを呼び出せるようにする技術。

# レガシーなフロントエンドのリファクタリング
* DOMとそれに関連する処理をまとめる。
* コード修正前に、同じ動作を行うかテストするためのコードを書いておく。
* [E2Eテスト] ユーザーから見た時のシステムの振る舞いをテストする。例、・id=searchのbutton要素をクリックするとsearchBooks関数が実行される、のは振る舞いではなく、本の名称で検索して一覧表示できる、が振る舞い。seleniumなどの活用。

# パッケージマネージャー
* パッケージマネージャーを導入する。ライブラリのバージョン管理や依存関係、環境再現など、手動では限界がある。JavaならMavenやGradle、JSなら


# 画面遷移
* [戻るの制御] ブラウザの戻るによる再postを防ぐため、ブラウザの機能を制限させたり、PRG（post, redirect, get）にしたり、セッションの中身を消したり、トークンによって制御したりと様々な方法がある。画面遷移をしっかり設計し、いつ誰がどの画面からどのアクションをしたか分かるようなログ設計も必要。
* [ブラウザのキャッシュ機能] 
* [子画面のモーダルとモードレス] モーダルは親画面を見れず、触れずだが、ユーザーの操作を制限できる。モードレスはいろんな子画面を出して操作できるが、ユーザーのさまざまな操作を考慮する必要がある。子画面は要件確認が重要。モードレスではセッション上書きに注意。
* [画面間のデータ引き継ぎ] hidden方式とセッション方式。セッション方式にはメモリオーバーの可能性が、hidden方式には通信ネックや改ざんリストがある。

# local strage, session strage
* ローカルストレージは保持期限がなく、セッションストレージはブラウザが閉じられるまで保持される。localStrage.setItam(キー, 値)でセットし、localStrage.getItam(キー)で取り出す。


# GETとPOST
* GETはURLにパラメータを載せる。
* POSTのパラメータは開発者ツールなどのネットワークキャプチャで見れる。

# MVC
## ビューモデル
ビューとして表示／操作すべきデータ。エンティティをそのままビューモデルとして利用することもあるが、エンティティから一部のプロパティを取り出したり、複数のエンティティを組み合わせたり、エンティティとは対応関係にない項目をビューモデルとして表すようなこともある。

# HTML
* 構造を考える。クラスやIDを考える。
* 各コンポーネントの位置（float,padding,border,margin）、サイズ（width,height）、デザイン（color,radius,block)を決める。
* [formタグ] method要素にはGETかPOST。GETはURLの末尾にパラメータなどを追記してリクエストできる。postはフォームの内容を付けてリクエスト(URLには追記しない、正確にはリクエストのヘッダー内に書き込まれる)。action要素にはリクエストするURL。/を付けなければ相対パス。
* [inputタグ] type要素はテキストボックスやボタンなどを指定。name要素はinputの内容を扱うために必要。その名前で指定して入力された値などを扱う。

# CSS
* margin, border, padding
* top, right, bottom, left

* その要素が本来インライン要素なのかブロック要素なのかは把握するとレイアウトしやすい。
* htmlの構造を整理して、シンプルなCSSを保つ。
* 詳細度。全称セレクター、タイプセレクター、クラスセレクター、属性セレクター、擬似クラスセレクター、idセレクター、style属性によるインライン設定、! important
* 指定するものは「配置」「表現（サイズ、形、色・透明度）」

* 後に書かれたものが優先
* 後に読み込まれるファイルが優先
* HTMLで複数のCSSを読み込む場合、CSSファイル同士が依存しているなら、CSSからimportするようにした方が良い。
* カスタムプロパティ（変数）を利用できる

### レスポンシブWebデザイン（RWD）
* リキッドレイアウト（MAXサイズを決めるなど）
* メディアクエリ（画面サイズに応じたスタイル適用）

### セレクター指定
* classは「.」、idは「#」で指定
* 複数のセレクターはカンマで繋ぐ
* 階層の絞り込み指定はスペースで繋ぐ
* 子要素指定は「>」で繋ぐ
* 同階層のすぐ後ろや後ろ以降は「+」や「~」で繋げる
* 擬似クラスは「:」、擬似要素は「::」
* セレクターの最初の要素や最後の要素、偶数番目の要素といった指定も可能。「:nth-child()」など
* 「:not」で指定セレクターを除外することもできる

# Web3/LiteCoin
* クローンして動かしてみる、コインを交換してみる
* CLIでAPI叩いてみる
* C++のソースを見て機能（API）リストアップ
    * C++環境をVMに用意
    * 検索候補: rpc, bitcoin-cli, helpman、API名(get--), test--, 
    * rpcフォルダの関数がどこで使われるか追ってみる
    * VSCodeのシンボル一覧表示機能を試す。
* 別端末のRPC呼び出してみる

# 習得
* 自由に書けるようになるにはサンプルを知ることから。構造（レイアウト）のサンプル、デザインのサンプル、JSによる動きや表現などのサンプル
* CSSのプロパティは頻繁なものだけ覚えて都度調べればいい。使ってれば勝手に覚える。
