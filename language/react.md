
# 基本
HTMLとJavasscriptをセットにしてコンポーネントとして定義する。
仮想DOMという仕組みで、実際のDOMと比較して差分のHTMLだけを更新する。
コンポーネントはクラスとしての表現方法と関数としての表現方法がある。（現在は主に関数コンポーネント）
コンポーネントは見た目と機能を持ったUI部品
1コンポーネント1ファイルにして分ける
子コンポーネントでexportすることで、親コンポーネントでimportできるようになる。
親から子に引数として渡す値がprops
コンポーネントを責務を明確にして分けることで、再利用しやすく、修正しやすく管理できる。

ツールチェインを使わない create react app という方法がある。Babel,Webpackなど
npx create-react-app

Reactコンポーネントが再描画されるきっかけは、state,propsが変更されたとき。

* 関数コンポーネントはその性質上、状態や副作用を持てない。その欠点を補う形でHooksがある。

## マウント・アンマウント
コンポーネントがDOMに追加されることをマウント、削除されることをアンマウントという。

## props
親コンポーネントから受け取る属性（値）
親のstateを変更する必要があるなら、propsで子にイベントハンドラを渡す。

## state
コンポーネント内部で管理する状態（値）
フックによってstateが変更されると再レンダーされる。

コンポーネント単位に保持する状態変数。これがReactの仕組みにより更新された時、再レンダーが行われる。

## 画面設計
最初に画面を設計し、どんなコンポーネントで構成するか、何（値、状態など）をどのコンポーネントで持つか考える。誰がハンドラーを定義して誰が実行するか。

# hooks
## useEffect
実行タイミングの制御のためのフック。DOMレンダリング後に実行される。主に副作用（UI構築以外の処理）を実行する。
コールバック関数から返されるクリーンアップ関数はアンマウント時に実行される。

処理の実行タイミングをレンダリング後まで遅らせるhook。

## useContext
Reactコンポーネントのツリーに対して「グローバル」とみなすデータについて利用するように設計されている。コンポーネントの再利用を難しくするため慎重に使う必要がある。

# export, import（コンポーネントをモジュールのように扱える）
default export, default import, 名前付きexport, 名前付きimport

# HTMLとの違い
* class -> className
* タグの属性に代入するときは { }

## ライフサイクル
ライフサイクルはコンポーネントが生成されてから削除されるまでの一連の流れ
内部のstateが更新された時、もしくは親コンポーネントから新しいpropsが渡された際にコンポーネントの更新処理が起きる。

mounting
コンポーネントが配置される期間
初期化→レンダリング→マウント後処理

updating
コンポーネントが変更される期間
レンダリング→更新後処理

unmounting
コンポーネントが破棄される期間
破棄前の処理

# コード
* stateの宣言
const [state, setState] = useState(initialState)
stateは引数名のようなもの、setStateは関数、initialStateが実際に渡す値のようなもの
* stateの更新
setState(newState)
* useEffect
useEffect( () => {
  処理
}, 第2引数)
処理はレンダリングによって引き起こす処理（副作用）を書く。
第2引数は副作用が引き起こされるかどうかの依存関係を書く。例えば空配列を入れると初回レンダリングのみ実行される処理となる。
return で返す関数はクリーンアップ関数となり、レンダリング直前に行う処理
非同期処理はuseEffect内で書くことが多い。


# react 公式doc
## JSX
マークアップとロジックを分離（技術の分離）するのではなく、コンポーネントの単位で関心の分離を行う。
JSXは式である。コンパイルの後、JSの関数呼び出しに変換され、JSオブジェクトへと評価される。
JSXでJSの値は{}で渡す。JSオブジェクトを渡す場合はオブジェクトを{}でラップする。（{{}}となる）

DOMを値として考えて仮想DOMで操作する。レンダリング時にDOMとの差分を抽出する。

JSXの実体は、CreateElementによって生成されたReact要素。

## レンダーされた要素の更新
React要素はイミュータブル。一度作成すると子要素や属性は変更できない。特定のある時点のUI。

## コンポーネントとprops
propsはタグのクラスやIDみたいなもの。この値によってコンポーネントをカスタマイズできる。
概念的にはコンポーネントはJSの関数に似ている。propsという任意の入力を受け取り、画面上に表示すべきものを記述するReact要素を返す。

関数コンポーネント（コンポーネントを定義するシンプルな方法：JSの関数）（こちらが主流？）
function Welcom(props) {
    return <h1>hello, {props.name}</h1>;
}
クラスコンポーネント
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}

コンポーネントは最初は大文字推奨
コンポーネントが使用される文脈ではなく、コンポーネント自身からの観点でpropsの名前を付ける。
UIの一部（ボタンなど）が複数回使われている場合や、そのUI自体が複雑な場合は別コンポーネントとして抽出する価値は大きい。

全ての React コンポーネントは、自己の props に対して純関数のように振る舞わねばなりません。自分自身のpropsは変更してはいけない。

## propsとstate
原則として、propsはコンポーネントのレンダリングを設定する際に使い、stateは時間経過で変化するようなデータ（状態）を追跡する際に使う。

## stateとライフサイクル
ライフサイクルメソッド
多くのコンポーネントを有するアプリケーションでは、コンポーネントが破棄された場合にそのコンポーネントが占有していたリソースを解放することが重要。componentDidMount、componentWillUnmountなどのライフサイクルメソッドを活用する。
renderメソッドは更新が発生するたびに呼ばれる。これによりReactは何を表示すべきかを知る。その後ReactはDOMをレンダー出力と一致するように更新する。
componentDidMountメソッドは出力がDOMにレンダーされた後に実行される処理。
constructor > render > （出力がDOMに挿入されると）componentDidMount

stateは直接変更せず、setStateを利用する。（直接更新できるのはコンストラクタ内のみ）
this.propsとthis.stateは非同期に更新される。そのためお互いの値に依存するべきではない。
stateはコンポーネント自身以外からはアクセスできない。ローカル、カプセル化されている。
コンポーネントは子コンポーネントにpropsとして自身のstateを渡すことはできる。つまりstateはそのコンポーネントよりも下にのみ影響する。任意の場所で追加で合流してくる水源のようなもの。

## others
Viewタグ、Textタグはそれぞれdivタグ、pタグのようなもの。
ほとんどのCoreComponentsはpropsによってカスタマイズ可能。（Imageコンポーネントのsourceなど）
useStateはコンポーネントに状態を追加できる関数コンポーネント。
    stateの再設定時には再レンダリングされる。
    const [<getter>, <setter>] = useState(<initialValue>)


# フック
要は関数コンポーネントで扱える関数。ロジックを分離でき、テストや再利用がしやすくなる。

## useState
stateとstate更新関数を返すフック。
stateは画面に表示するデータやUIの状態。アプリケーションが保持している情報。
state管理では、stateの保持とstateの更新を行う。
stateの変更により再レンダーを行う。
複数のstateをひとつのオブジェクトでまとめることもできる。

## useEffect
コンポーネントに副作用（Reactから生成されたDOMの変更、API通信、非同期処理など）を追加する。
コンポーネントのレンダー後やアンマウント（コンポーネント廃棄）後に副作用を実行する。
引数の渡し方によって、毎回実行したり、一度だけ実行させたり、特定の値が変更された時だけ実行てきる。

## useRef
DOMの参照や値の保持をする。useStateとは異なり、useRefで生成した値を更新しても再レンダーされない。レンダーに関係ないstateを扱いたい時に利用。

## React.memo
コンポーネントのレンダー結果をメモ化する。
レンダーコストの高いコンポーネントや、頻繁に再レンダーされるコンポーネント内の子コンポーネントの再レンダーをスキップしてパフォーマンスを上げる。
propsの等価性をチェックして再レンダーを判断する。
useCallback、useMemo と併せて使う。
パフォーマンス向上が必要になった際に利用を検討すれば良い？

## useReducer
stateとdispatch（actionを送信する関数）を返すフック。
複雑なstate更新を行う時に使うと良い？

## useContext

## カスタムフック
コンポーネントから切り出したロジックを定義した関数。

# 構造
各.tsx -> App.tsx -> index.tsx -> index.html

# クラスコンポーネント
* reactモジュールのComponentクラスを継承
* renderメソッドで描画内容（React要素）を返す


## 今後の調査課題
* 実際に作るアプリを決める。作りながら必要な知識を調査していく。
* 画面遷移、ナビゲーション
    * Stack
    * タブ
    * Drawer
    * 自由なレイアウトのOptions
    * ルーティングのheaderModeとmode
* UIライブラリの利用
* 認証、Firebase
* E2E
* Redux（Fluxアーキテクチャの影響を受けたライブラリ）。双方向データバインドのMVVMと比較した単一方向アーキ。
* atomic Design（基はデザイン設計）とコンポーネント設計
* コンポーネントのユニットテスト
* Next.jsと4つのレンダリング手法（SSGなど）
* ビルドツールとタスクランナー
* フック15種とカスタムフック
* メモ化
* CI、デプロイ
